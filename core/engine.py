import importlib
import pkgutil
import threading
import time
import logging
from typing import List

from core.config import config
from core.mt5_client import MT5Client
from strategies.base_strategy import BaseStrategy
import strategies  # Import the package to find submodules

# Configure logging
log = logging.getLogger(__name__)


class TradingEngine(threading.Thread):
    """
    The main trading engine of the bot.

    This class runs in a separate thread and orchestrates all trading activities.
    It manages connections to multiple MT5 accounts, loads trading strategies,
    and executes trades based on the signals generated by those strategies.
    """

    def __init__(self):
        super().__init__()
        self.daemon = True  # Allows main program to exit even if this thread is running
        self._is_running = False
        self.clients: List[MT5Client] = []
        self.loaded_strategies: List[BaseStrategy] = []

        self._initialize_clients()
        self._load_strategies()

    def _initialize_clients(self):
        """Initializes MT5 clients for all enabled accounts in the config."""
        log.info("Initializing MT5 clients...")
        for acc_config in config.accounts:
            if acc_config.enabled:
                client = MT5Client(acc_config)
                self.clients.append(client)
                log.info(f"Client for account {acc_config.account_id} created.")
            else:
                log.warning(f"Account {acc_config.account_id} is disabled in config.")

    def _load_strategies(self):
        """Dynamically loads all strategy classes from the 'strategies' directory."""
        log.info("Loading strategies...")
        # Path to the strategies package
        package = strategies
        for _, name, _ in pkgutil.walk_packages(package.__path__, package.__name__ + '.'):
            module = importlib.import_module(name)
            for attribute_name in dir(module):
                attribute = getattr(module, attribute_name)
                if isinstance(attribute, type) and issubclass(attribute, BaseStrategy) and attribute is not BaseStrategy:
                    # This is where strategies are instantiated.
                    # In a production system, parameters would be loaded from the database
                    # for each strategy associated with an account.
                    # For this MVP, we'll instantiate our example strategy with default params.
                    if attribute.__name__ == "MovingAverageCrossoverStrategy":
                        # Default parameters for a day-trading setup on an hourly chart
                        params = {
                            "symbol": "EURUSD",
                            "short_ma_period": 20,
                            "long_ma_period": 50,
                            "timeframe": "TIMEFRAME_H1"
                        }
                        instance = attribute(name=attribute.__name__, params=params)
                        self.loaded_strategies.append(instance)
                        log.info(f"Successfully loaded strategy: {attribute.__name__} with params {params}")

    def run(self):
        """The main trading loop of the engine."""
        self._is_running = True
        log.info("Trading engine started.")

        # Connect all clients
        for client in self.clients:
            client.connect()

        while self._is_running:
            try:
                for client in self.clients:
                    if not client.is_connected():
                        log.warning(f"Client for account {client.account_id} is not connected. Skipping.")
                        continue

                    # --- Risk Management Check ---
                    open_positions = client.get_open_positions()
                    if len(open_positions) >= config.risk_management.max_open_trades:
                        log.warning(f"Max open trades limit reached for account {client.account_id}. No new trades will be placed.")
                        continue

                    # --- Strategy Execution ---
                    for strategy in self.loaded_strategies:
                        # This logic will be expanded to handle strategy-specific symbols
                        symbol = strategy.params.get('symbol', 'EURUSD') # Example
                        signal = strategy.check_signal(client, symbol)

                        if signal == "BUY":
                            log.info(f"BUY signal received from {strategy.name} for {symbol} on account {client.account_id}")
                            # Placeholder for volume calculation
                            client.place_order(symbol, order_type=0, volume=0.01) # 0 = ORDER_TYPE_BUY
                        elif signal == "SELL":
                            log.info(f"SELL signal received from {strategy.name} for {symbol} on account {client.account_id}")
                            client.place_order(symbol, order_type=1, volume=0.01) # 1 = ORDER_TYPE_SELL

                # Pause for a configurable interval to avoid excessive CPU usage
                time.sleep(60)  # Check for signals every minute

            except Exception as e:
                log.error(f"An error occurred in the trading loop: {e}", exc_info=True)
                time.sleep(60) # Wait before retrying after an error

        # Disconnect all clients on exit
        for client in self.clients:
            client.disconnect()
        log.info("Trading engine stopped.")

    def start_engine(self):
        """Starts the trading engine thread."""
        if not self.is_alive():
            self.start()

    def stop_engine(self):
        """Stops the trading engine thread gracefully."""
        log.info("Stopping trading engine...")
        self._is_running = False
        # The join() will be called from the main thread to wait for this thread to finish
        # For now, we just set the flag. A more robust shutdown might use an Event.
